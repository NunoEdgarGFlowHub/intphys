import os

import unreal_engine as ue
from tools.scene import TrainScene, TestScene
from tools.tick import Tick
from tools.utils import exit_ue


def parse_scenes_json(world, scenes_json):
    """Return a list of scenes to be generated by the scheduler

    Parameters
    ----------
    world : UE World
        The game's world hosting the scenes's rendering
    scenes_json : dict
        A dictionary loaded from an input scenes configuration
        file. For an exemple of such a file, see
        intphys/Exemples/exemple.json. Defines a number of train and
        test scenes to execute for each scenario.

    Returns
    -------
    A list of instances of TestScene and TrainScene

    """
    scenes = []

    # iterate on the blocks defined in the configuration
    for scenario, cases in scenes_json.items():
        # 'scenario_O1' -> 'O1'
        scenario = scenario.split('_')[1]

        for k, v in cases.items():
            # train case, v is the number of scenes to generate
            if 'train' in k:
                nscenes = v
                scenes += [TrainScene(world, scenario) for _ in range(nscenes)]
            else:  # test scenes in the form 'test_visible' or 'test_occluded'
                is_occluded = 'occluded' in k
                for condition, nscenes in v.items():
                    # condition is 'static', 'dynamic_1' or 'dynamic_2'
                    is_static = 'static' in condition
                    ntricks = 2 if condition.endswith('2') else 1
                    scenes += [
                        TestScene(world, scenario, is_occluded, is_static, ntricks)
                        for _ in range(nscenes)]

    return scenes


class Scheduler:
    """Render a list of intuitive physics scenes

    The scheduler is attached to a given UE `world` in which it
    renders the scenes defined in `scenes_json`, optionally tales
    screenshots and save them to `output_dir`

    """
    def __init__(self, world, scenes_json, output_dir=None):
        self.world = world

        # generate the list of scenes from the input JSON file
        self.scenes_list = parse_scenes_json(self.world, scenes_json)
        ue.log('scheduling {nscenes} scenes, ({ntest} for test and '
               '{ntrain} for train), total of {nruns} runs'.format(
            nscenes=len(self.scenes_list),
            ntest=len([s for s in self.scenes_list if isinstance(s, TestScene)]),
            ntrain=len([s for s in self.scenes_list if isinstance(s, TrainScene)]),
            nruns=sum(s.get_nruns() for s in self.scenes_list)))

        self.scene_index = 0
        self.scene = self.scenes_list[0]

        # init the scene for 100 ticks (and 100 images) per run
        self.ticker = Tick(nticks=100)

        # call run() to generate the next run at the end of the
        # current one
        self.ticker.add_hook(self.run_next, 'final')

        # start the ticker and render the first scene
        self.ticker.run()
        self.run()

    def run(self):
        """Render the current scene"""
        description = 'rendering scene {}/{}: {}'.format(
            self.scene_index+1, len(self.scenes_list), self.scene.description())
        ue.log(description)
        # TODO for debug
        ue.print_string(description)

        self.scene.render()

    def run_next(self):
        """Setup the next run for rendering, finally exit the game"""
        # if the current run failed, restart the whole scene with new
        # random parameters
        if not self.scene.is_valid():
            ue.log_warning('scene failed, retry it')
            self.scene.reset()

        # if no more run for that scene, render the next scene (else
        # render the next run of the current scene)
        if self.scene.get_nruns_remaining() == 0:
            self.scene_index += 1
            try:
                self.scene = self.scenes_list[self.scene_index]
            except IndexError:
                ue.log_warning('all scenes rendered, exiting')
                exit_ue(self.world)
                return

        # render the run
        self.run()

    def tick(self, dt):
        self.ticker.tick(dt)
