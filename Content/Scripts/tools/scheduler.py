import os

import unreal_engine as ue
from unreal_engine import FVector
from unreal_engine.classes import Screenshot

from tools.scene import TrainScene, TestScene
from tools.tick import Tick
from tools.utils import exit_ue
from actors.camera import Camera


def parse_scenes_json(world, scenes_json):
    """Return a list of scenes to be generated by the scheduler

    Parameters
    ----------
    world : UE World
        The game's world hosting the scenes's rendering
    scenes_json : dict
        A dictionary loaded from an input scenes configuration
        file. For an exemple of such a file, see
        intphys/Exemples/exemple.json. Defines a number of train and
        test scenes to execute for each scenario.

    Returns
    -------
    A list of instances of TestScene and TrainScene

    """
    scenes = []

    # iterate on the blocks defined in the configuration
    for scenario, cases in scenes_json.items():
        # 'scenario_O1' -> 'O1'
        scenario = scenario.split('_')[1]

        for k, v in cases.items():
            # train case, v is the number of scenes to generate
            if 'train' in k:
                nscenes = v
                scenes += [TrainScene(world, scenario) for _ in range(nscenes)]
            else:  # test scenes in the form 'test_visible' or 'test_occluded'
                is_occluded = 'occluded' in k
                for condition, nscenes in v.items():
                    # condition is 'static', 'dynamic_1' or 'dynamic_2'
                    is_static = 'static' in condition
                    ntricks = 2 if condition.endswith('2') else 1
                    scenes += [
                        TestScene(world, scenario, is_occluded, is_static, ntricks)
                        for _ in range(nscenes)]

    return scenes


class Scheduler:
    """Render a list of intuitive physics scenes

    The scheduler renders each scene defined in `scenes_json`. It
    optionally takes screenshots and saves them to `output_dir`.

    Parameters
    ----------
    world : ue.uobject
        The game's world in which to render the scenes
    scenes_json : dict
        A dictionary loaded from a scenes json configuration file, see
        intphys/Exemples/exemple.json
    scene_size : tuple
        The size of a scene the screen resolution times the number of
        images captured in a single scene, in the form (width, height,
        nimages).
    output_dir : str, optional
        When specified, the directory where to write PNG images and
        metadata from the rendered scenes. When ignored (default), do
        not take captures nor save any data (dry mode).

    """
    def __init__(self, world, scenes_json, scene_size, output_dir=None):
        self.world = world
        self.output_dir = output_dir

        # the scheduler owns the camera
        self.camera = Camera(world, FVector(0, 0, 150))

        # generate the list of scenes from the input JSON file
        self.scenes_list = parse_scenes_json(self.world, scenes_json)
        ue.log('scheduling {nscenes} scenes, ({ntest} for test and '
               '{ntrain} for train), total of {nruns} runs'.format(
            nscenes=len(self.scenes_list),
            ntest=len([s for s in self.scenes_list if isinstance(s, TestScene)]),
            ntrain=len([s for s in self.scenes_list if isinstance(s, TrainScene)]),
            nruns=sum(s.get_nruns() for s in self.scenes_list)))

        self.scene_index = 0
        self.scene = self.scenes_list[0]

        # init the scene for n ticks (and n screenshot captures) per run
        self.ticker = Tick(nticks=scene_size[2])

        # setup the screenshots
        if self.output_dir:
            Screenshot.Initialize(
                int(scene_size[0]), int(scene_size[1]), int(scene_size[2]),
                self.camera.get_actor())

        # call run() to generate the next run at the end of the
        # current one
        self.ticker.add_hook(self.run_next, 'final')

        # start the ticker and render the first scene
        self.ticker.run()
        self.run()

    def scene_output_dir(self):
        """Return the output directory for the current run"""
        # build the scene sub-directory name, for exemple '027_test_O1'
        idx = self.scene_index + 1
        padded_idx = '0' * len(str(len(self.scenes_list) - idx)) + str(idx)
        scene_name = (
            padded_idx + '_' +
            ('train' if self.scene.is_train_scene() else 'test') + '_' +
            self.scene.scenario)

        out = os.path.join(self.output_dir, scene_name)

        if not self.scene.is_train_scene():
            # 1, 2, 3 and 4 subdirectories
            run_idx = self.scene.get_nruns() - self.current_run + 1
            out = os.path.join(out, run_idx)

        ue.log('created output dir %s' % out)
        # ue.print_string(out)
        return out

    def run(self):
        """Render the current scene, capturing screenshots when required"""
        description = 'rendering scene {}/{}: {}'.format(
            self.scene_index+1, len(self.scenes_list), self.scene.description())
        ue.log(description)
        # ue.print_string(description)

        # capture screenshots, only if this is not a check run
        if self.output_dir and not self.scene.is_check_run():
            def save_capture():
                output_dir = self.scene_output_dir()
                # done, max_depth, masks = Screenshot.Save(output_dir)
                Screenshot.Reset()
                # ue.log('max depth is {}'.format(max_depth))
                # ue.log('masks are {}'.format(masks))

            # register for ticking
            self.ticker.add_hook(Screenshot.Capture, 'slow')
            self.ticker.add_hook(save_capture, 'final')

        self.scene.render()

    def run_next(self):
        """Setup the next run for rendering, exit the game after last run"""
        # if the current run failed, restart the whole scene with new
        # random parameters
        if not self.scene.is_valid():
            ue.log_warning('scene failed, retry it')
            self.scene.reset()

        # if no more run for that scene, render the next scene (else
        # render the next run of the current scene)
        if self.scene.get_nruns_remaining() == 0:
            self.scene_index += 1
            try:
                self.scene = self.scenes_list[self.scene_index]
            except IndexError:
                ue.log_warning('all scenes rendered, exiting')
                self.ticker.stop()
                exit_ue(self.world)
                return

        # render the run
        self.run()

    def tick(self, dt):
        self.ticker.tick(dt)
